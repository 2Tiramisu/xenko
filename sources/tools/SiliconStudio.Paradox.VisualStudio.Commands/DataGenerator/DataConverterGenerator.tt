<#@ template language="C#" visibility="public" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="SiliconStudio.AssemblyProcessor" #>
// <auto-generated>
// Do not edit this file yourself!
//
// This code was generated by Paradox Data Code Generator.
// To generate it yourself, please install SiliconStudio.Paradox.VisualStudio.Package .vsix
// and re-save the associated .pdxdata.
// </auto-generated>

namespace <#=assembly.Name.Name#>.Data
{
    /// <summary>
    /// Module initializer for data types of assembly <#=assembly.Name.Name#>.
    /// </summary>
    class DataInitializer
    {
        [SiliconStudio.Core.ModuleInitializer]
        internal static void Initialize()
        {
<#foreach (var type in processedConverterTypes)
{
	var dataConverterInfo = type.Value;
#>
            // Register type <#=dataConverterInfo.DataInfo.Type.Name#>
            SiliconStudio.Core.Serialization.Converters.ConverterContext.RegisterConverter(new <#=dataConverterInfo.Type.ConvertCSharp()#>());
<# if ((dataConverterInfo.DataInfo.Flags & DataTypeFlags.EntityComponent) != 0) { #>
            // Register entity component reference for type <#=dataConverterInfo.DataInfo.Type.Name#>
            SiliconStudio.Core.Serialization.Converters.ConverterContext.RegisterConverter(new SiliconStudio.Paradox.EntityModel.EntityComponentReferenceDataConverter<<#=type.Key.ConvertCSharp()#>>());
<# } } // foreach (var type in processedConverterTypes)#>
        }
    }
}

<#foreach (var type in processedTypes)
{
	var dataTypeInfo = type.Value;
	var isAutoGenerated = (type.Value.Flags & DataTypeFlags.Generated) != 0;
	ChangeNamespace(dataTypeInfo.Type.Namespace);
#>
    /// <summary>
    /// Data type for <see cref="<#=type.Key.ConvertCSharp()#>"/>.
    /// </summary>
    [SiliconStudio.Core.DataContract("<#=dataTypeInfo.Type.Name + dataTypeInfo.Type.GenerateGenerics()#>")]
<#if ((type.Value.Flags & DataTypeFlags.ContentReference) != 0) {#>
    [SiliconStudio.Core.Serialization.Contents.ContentSerializer(typeof(SiliconStudio.Core.Serialization.Contents.DataContentSerializer<<#=dataTypeInfo.Type.Name + dataTypeInfo.Type.GenerateGenerics()#>>))]
    [SiliconStudio.Core.Serialization.Contents.ContentSerializer(typeof(SiliconStudio.Core.Serialization.Converters.DataContentConverterSerializer<<#=dataTypeInfo.Type.Name + dataTypeInfo.Type.GenerateGenerics()#>, <#=type.Key.ConvertCSharp()#>>))]
<#}#>
    public partial class <#=dataTypeInfo.Type.Name + dataTypeInfo.Type.GenerateGenerics()#><# if (type.Value.BaseType != null) { #> : <#=type.Value.BaseType.ConvertCSharp()#><#}#>

    {
<#if (isAutoGenerated) {
    bool firstLine = true;
	foreach (var property in type.Value.Properties) {
      if (!firstLine) { this.Write("\r\n"); }
	  firstLine = false;#>
        /// <summary>
        /// Data field for <see cref="<#=type.Key.ConvertCSharp()#>.<#=property.Name#>"/>.
        /// </summary>
        public <#=property.DataType.ConvertCSharp()#> <#=property.Name#><#
// Add object initialization code (usually for List/Dictionary)
if (property.InitializerType != null) {#> = new <#=property.InitializerType.ConvertCSharp()#>()<#} #>;
<#} // end foreach
} // end if#>
    }

<#} // end while#>


<#foreach (var type in processedConverterTypes)
{
	var dataConverterInfo = type.Value;
	var dataTypeInfo = dataConverterInfo.DataInfo;
	var isAutoGenerated = dataConverterInfo.Generate;

	var objectTypeCSharp = type.Key.ConvertCSharp();
	var dataTypeCSharp = dataTypeInfo.Type.ConvertCSharp();

	var baseType = type.Key.BaseType != null? type.Key.BaseType.Resolve(): null;
	var baseTypeFlags = baseType != null? GetDataTypeFlags(baseType): null;
	var isInherited = baseTypeFlags != null && (baseTypeFlags.Value & DataTypeFlags.NoDataType) == 0;
	var baseDataType = isInherited? GetDataType(baseType): null;
	var baseConverterType = isInherited? GetDataConverterType(baseType): null;

	if (isAutoGenerated)
	{
			ChangeNamespace(dataConverterInfo.Type.Namespace);
#>
    /// <summary>
    /// Converter type for <see cref="<#=type.Key.ConvertCSharp()#>"/>.
    /// </summary>
    public partial class <#=dataConverterInfo.Type.Name#><#=dataConverterInfo.Type.GenerateGenerics()#> : <#if(isInherited){#><#=baseConverterType.ConvertCSharp()#><#}else{#>SiliconStudio.Core.Serialization.Converters.DataConverter<<#=dataTypeCSharp#>, <#=objectTypeCSharp#>><#}#>
	
	{
<#if(isInherited){#>
		/// <inheritdoc/>
		public override System.Type DataType
		{
			get { return typeof(<#=dataTypeCSharp#>); }
		}

		/// <inheritdoc/>
		public override System.Type ObjectType
		{
			get { return typeof(<#=objectTypeCSharp#>); }
		}
				
        /// <inheritdoc/>
        public override void ConvertFromData(SiliconStudio.Core.Serialization.Converters.ConverterContext converterContext, object data, ref object obj)
        {
            var dataT = (<#=dataTypeCSharp#>)data;
            var objT = (<#=objectTypeCSharp#>)obj;
            ConvertFromData(converterContext, dataT, ref objT);
            obj = objT;
        }
		
        /// <inheritdoc/>
        public override void ConvertToData(SiliconStudio.Core.Serialization.Converters.ConverterContext converterContext, ref object data, object obj)
        {
            var dataT = (<#=dataTypeCSharp#>)data;
            var objT = (<#=objectTypeCSharp#>)obj;
            ConvertToData(converterContext, ref dataT, objT);
            data = dataT;
        }

		<# } #>
<#if ((dataTypeInfo.Flags & DataTypeFlags.CustomConvertToData) == 0) {#>
        /// <inheritdoc/>
        public <#if(!isInherited){#>override <#}#>void ConvertToData(SiliconStudio.Core.Serialization.Converters.ConverterContext context, ref <#=dataTypeCSharp#> target, <#=objectTypeCSharp#> source)
        {
<#if(!dataTypeInfo.Type.IsValueType){#>
			if(target == null)
                target = new <#=dataTypeCSharp#>();
				
<#}#>
<#if(isInherited){#>
			{
				var targetBase = (<#=baseDataType.ConvertCSharp()#>)target;
				var sourceBase = (<#=baseType.ConvertCSharp()#>)source;
				ConvertToData(context, ref targetBase, sourceBase);
			}

<# } #>
<#foreach (var property in dataTypeInfo.Properties) {
if (property.DataType == property.OriginalType) {#>
            target.<#=property.Name#> = source.<#=property.Name#>;
<#} else {#>
            context.ConvertToData(ref target.<#=property.Name#>, source.<#=property.Name#>);
<#}} // end foreach#>
        }
<#} // if DataTypeFlags.CustomConvertToData#>

<#if ((dataTypeInfo.Flags & DataTypeFlags.CustomConvertFromData) == 0) {#>
<# if ((dataConverterInfo.DataInfo.Flags & DataTypeFlags.EntityComponent) != 0) { #>
        public override bool CanConstruct
        {
            get { return true; }
        }
		
<#if(isInherited){#>		
        /// <inheritdoc/>
        public override void ConstructFromData(SiliconStudio.Core.Serialization.Converters.ConverterContext converterContext, object data, ref object obj)
        {
            var dataT = (<#=dataTypeCSharp#>)data;
            var objT = (<#=objectTypeCSharp#>)obj;
            ConstructFromData(converterContext, dataT, ref objT);
            obj = objT;
        }

<#}#>
		/// <inheritdoc/>
        public <#if(!isInherited){#>override <#}#>void ConstructFromData(SiliconStudio.Core.Serialization.Converters.ConverterContext context, <#=dataTypeCSharp#> target, ref <#=objectTypeCSharp#> source)
		{
			source = new <#=objectTypeCSharp#>();
		}

<# } #>
        /// <inheritdoc/>
        public <#if(!isInherited){#>override <#}#>void ConvertFromData(SiliconStudio.Core.Serialization.Converters.ConverterContext context, <#=dataTypeCSharp#> target, ref <#=objectTypeCSharp#> source)
        {
<# // EntityComponent have a separate ConstructFromData
   if ((dataConverterInfo.DataInfo.Flags & DataTypeFlags.EntityComponent) == 0) { #>
<#if(!type.Key.IsValueType){#>
            if(source == null)
                source = new <#=objectTypeCSharp#>();

<#}#>
<#if(isInherited){#>
			{
				var targetBase = (<#=baseDataType.ConvertCSharp()#>)target;
				var sourceBase = (<#=baseType.ConvertCSharp()#>)source;
				ConvertFromData(context, targetBase, ref sourceBase);
			}

<# } #>
<# } #>
<#foreach (var property in dataTypeInfo.Properties) {
if (property.DataType == property.OriginalType) {#>
            source.<#=property.Name#> = target.<#=property.Name#>;
<#} else {#>
            {
                var temp = source.<#=property.Name#>;
                context.ConvertFromData(target.<#=property.Name#>, ref temp);
<#if (property.HasPublicSetAccessor) {#>
                source.<#=property.Name#> = temp;
<#} // if (property.HasPublicSetAccessor)#>
            }
<#}} // end foreach#>
        }
<#} // if DataTypeFlags.CustomConvertFromData#>
    }
<#} // end if#>

<#} // end while#>
<# ChangeNamespace(string.Empty); #>
