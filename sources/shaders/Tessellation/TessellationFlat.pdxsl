// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
/// <summary>
/// Tessellates without displacing.
/// </summary>
/// <remarks>
/// InputControlPointCount: Macro - number of input control points.
/// </remarks>

#ifndef InputControlPointCount
#define InputControlPointCount 3
#endif

class TessellationFlat : TessellationBase
{
    stage override float ComputeClipping(InputPatch<Input, InputControlPointCount> input, const OutputPatch<Input2, 3> output, inout Constants constants)
    {
        return ComputeClippingGroup3(input[0].PositionWS, input[1].PositionWS, input[2].PositionWS, ViewProjection);
    }

    float ComputeClippingGroup3(float4 f3Position1, float4 f3Position2, float4 f3Position3, float4x4 f4x4ViewProjection)
    {
        float4 clipPos1 = mul( float4( f3Position1.xyz, 1.0f ), f4x4ViewProjection );
        float4 clipPos2 = mul( float4( f3Position2.xyz, 1.0f ), f4x4ViewProjection );
        float4 clipPos3 = mul( float4( f3Position3.xyz, 1.0f ), f4x4ViewProjection );

        float3 planeTest;

        planeTest.x = ((-clipPos1.w <= clipPos1.x && clipPos1.x <= clipPos1.w) ? 1.0f : 0.0f)
                    + ((-clipPos2.w <= clipPos2.x && clipPos2.x <= clipPos2.w) ? 1.0f : 0.0f)
                    + ((-clipPos3.w <= clipPos3.x && clipPos3.x <= clipPos3.w) ? 1.0f : 0.0f);

        planeTest.y = ((-clipPos1.w <= clipPos1.y && clipPos1.y <= clipPos1.w) ? 1.0f : 0.0f)
                    + ((-clipPos2.w <= clipPos2.y && clipPos2.y <= clipPos2.w) ? 1.0f : 0.0f)
                    + ((-clipPos3.w <= clipPos3.y && clipPos3.y <= clipPos3.w) ? 1.0f : 0.0f);

        planeTest.z = ((-clipPos1.w <= clipPos1.z && clipPos1.z <= clipPos1.w) ? 1.0f : 0.0f)
                    + ((-clipPos2.w <= clipPos2.z && clipPos2.z <= clipPos2.w) ? 1.0f : 0.0f)
                    + ((-clipPos3.w <= clipPos3.z && clipPos3.z <= clipPos3.w) ? 1.0f : 0.0f);

        return !all(planeTest != 0.0f) ? 1.0 : 0.0;
    }

    stage override void InterpolateBarycentric(const OutputPatch<Input, 3> input, in Constants constants, float3 f3BarycentricCoords)
    {
        //streams = input[0] * fU + input[1] * fV + input[2] * fW;

        float fU = f3BarycentricCoords.x;
        float fV = f3BarycentricCoords.y;
        float fW = f3BarycentricCoords.z;

        streams = input[0] * fU + input[1] * fV + input[2] * fW;
    }
};
