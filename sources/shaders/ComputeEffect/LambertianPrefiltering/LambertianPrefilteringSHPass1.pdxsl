// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Paradox.Effects.Images
{
    /// <summary>
    /// The first pass of a shader performing Lambertian pre-filtering using Spherical Harmonics
    /// </summary>
    class LambertianPrefilteringSHPass1<int TBlockSize, int THarmonicsOrder> : SphericalHarmonicsBase<THarmonicsOrder>, ComputeShaderBase, Texturing
    {    
        // the input texture containing the radiance
        TextureCube<float4> RadianceMap;

        // the output buffer containing SH coefficient partially summed.
        RWBuffer<float4> OutputBuffer;
    
        // Shared memory for summing SH-Basis coefficients for a block
        groupshared float4 PartialSHCoeffs[TBlockSize][TBlockSize][CoefficientsCount];
        
        // Projects radiance on SH basis and sums results along rows.
        override void Compute()
        {
	        // Determine the indices of the texel to compute
	        const int3 location = int3(streams.GroupThreadId.xy + streams.GroupId.xy * TBlockSize, streams.GroupId.z);

	        // Calculate the location in [-1, 1] texture space (center at the pixel center)
	        float u =   ((location.x+0.5) / float(streams.ThreadCountX)) * 2.0f - 1.0f;
	        float v = -(((location.y+0.5) / float(streams.ThreadCountY)) * 2.0f - 1.0f);

	        // Extract direction from texel u,v
	        float3 dirVS = normalize(CubemapUtils.ConvertTexcoordsNoFlip(float2(u, v), location.z));
	        float3 radiance = RadianceMap.SampleLevel(Texturing.PointSampler, dirVS, 0).xyz;

	        // Calculate weight
	        float temp = 1.0f + u * u + v * v;
	        float weight = 4.0f / (sqrt(temp) * temp);
	        radiance *= weight;

            // Calculates the values of the SH bases
            EvaluateSHBases(dirVS);

	        // Store the results in the shared memory
            [unroll]
            for(int c=0; c<CoefficientsCount; ++c)
            {
	            PartialSHCoeffs[streams.GroupThreadId.x][streams.GroupThreadId.y][c] = float4(streams.SHBaseValues[c] * radiance, weight);
            }
	        GroupMemoryBarrierWithGroupSync();

	        // Sum the coefficients along the block columns
		    if(streams.GroupThreadId.x == 0)
            {
	            for(int col=1; col<TBlockSize; ++col)
	            {
                    [unroll]
                    for(int c=0; c<CoefficientsCount; ++c)
                    {
	                    PartialSHCoeffs[0][streams.GroupThreadId.x][c] += PartialSHCoeffs[col][streams.GroupThreadId.x][c];
                    }
	            }
            }
		    GroupMemoryBarrierWithGroupSync();

	        // Sum the columns results
	        if(IsFirstThreadOfGroup())
	        {
	            for(int r=1; r<TBlockSize; ++r)
	            {
                    [unroll]
                    for(int c=0; c<CoefficientsCount; ++c)
                    {
	                    PartialSHCoeffs[0][0][c] += PartialSHCoeffs[0][r][c];
                    }
	            }
            }

	        // Have the first thread write out to the output texture
	        if(IsFirstThreadOfGroup())
	        {
                int2 groupCount = streams.ThreadGroupCount.xy;
                int indexBias = CoefficientsCount * (streams.GroupId.x + streams.GroupId.y * groupCount.x + groupCount.x * groupCount.y * location.z);

                [unroll]
		        for(int c = 0; c < CoefficientsCount; ++c)
		        {
			        OutputBuffer[indexBias + c] = PartialSHCoeffs[0][0][c];
		        }
	        }
        }
    };
}
