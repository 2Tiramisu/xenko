// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Paradox.Effects.Images
{

    /// <summary>
    /// A blur with uniform weights applied along one direction. 
    /// The blurring algorithm is also depth-aware: sample weights are modified on-the-fly to avoid 
    /// artifacts such as in-focus objects bleeding into out-of-focus background objects.
    /// Expects as input: 
    /// - Texture0: color buffer
    /// - Texture1: a [CoC, Linear Depth] buffer
    /// </summary>

    class DepthAwareUniformBlurUtil<int BlurCount> : Texturing, ComputeColor
    {
        // Direction to apply the blur. (normalized vector)
        float2 Direction;

        // The radius of the blur to apply around the considered fragment
        float Radius;

        // Weights of each tap
        float TapWeights[BlurCount];

        // Gets the blur result for the current pixel.
        override float4 Compute()
        {
            // Offset between 2 consecutive taps
            float2 tapOffset =  Radius / (BlurCount - 1) * Texture0TexelSize;

            // Initializes with the center point
            float totalWeight = TapWeights[0];
            float3 resultColor = Texture0.Sample(LinearSampler, streams.TexCoord).rgb;
            resultColor *= TapWeights[0];
            float centerDepth = Texture1.Sample(LinearSampler, streams.TexCoord).y;

            // Treats all the taps in the 2 directions from the center
            [unroll]
            for(int i = 1; i < BlurCount; i++)
            {
                [unroll]
                for (int j = -1.0; j <= 1.0; j += 2) // Backward(-1) and forward(+1) along the direction
                {                     
                    float2 tapUV = streams.TexCoord + j * i * Direction * tapOffset;
                    float2 cocDepth = Texture1.Sample(LinearSampler, tapUV).xy;

                    // We want to avoid color-bleeding due to depth occlusion: 
                    // tap's weight is recalculated to prevent artifacts
                    float contribution = (cocDepth.y >= centerDepth);
                    contribution += cocDepth.x;
                    contribution = saturate(contribution * sign(cocDepth.x));

                    float tapWeight = contribution * TapWeights[i];

                    float3 tapColor = Texture0.Sample(LinearSampler, tapUV).rgb;
                    resultColor += tapColor * tapWeight;
                    totalWeight += tapWeight;
                }
            }

            // Normalizes the final result
            return float4(resultColor / totalWeight, 1.0);
        }
    };
}
