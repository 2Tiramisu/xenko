// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
namespace SiliconStudio.Paradox.Effects.BRDF
{
    /// <summary>
    /// Utility class for calculating the various variations of the functions 
    /// (Fresnel, NDF and GeometricShadowing) involved in a Microfacet shading model.
    /// </summary>
    class BRDFMicrofacet : Math
    {
        // References:
        // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html
        // TODO: Add reference to original papers here

        // -------------------------------------------------
        // Normal Distribution Functions
        // -------------------------------------------------
        // Expected parameters:
        //    alphaR = roughness^2 (Burley)
        //    nDotH  = saturate(dot(n, h))
        // -------------------------------------------------
        // TODO Add GGX Anisotropic

        /// <summary>
        /// Calculate the NDF Blinn-Phong
        /// </summary>
        float NormalDistributionBlinnPhong(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            return pow(nDotH, 2/alphaR2 - 2) / (PI * alphaR2);
        }

        /// <summary>
        /// Calculate the NDF Beckmann
        /// </summary>
        float NormalDistributionBeckmann(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            var nDotH2 =  nDotH * nDotH;
            var nDotH4 =  nDotH2 * nDotH2;
            return exp((nDotH2 -1)/(alphaR2 * nDotH2))/(PI * alphaR2 * nDotH4);
        }

        /// <summary>
        /// Calculate the NDF GGX
        /// </summary>
        float NormalDistributionGGX(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            return alphaR2 / (PI * pow(nDotH * nDotH * (alphaR2 - 1) + 1, 2.0f));
        }

        // -------------------------------------------------
        // Fresnel Functions
        // -------------------------------------------------
        // Expected parameters:
        //    f0 = fresnel specular color at angle 0
        //    vDotH  = saturate(dot(v, h))
        // -------------------------------------------------

        /// <summary>
        /// Calculate a nop Fresnel.
        /// </summary>
        float3 FresnelNone(float3 f0)
        {
            return f0;
        }

        /// <summary>
        /// Calculate a Schlick approximation to Fresnel 
        /// </summary>
        float3 FresnelSchlick(float3 f0, float lOrVDotH)
        {
            return FresnelSchlick(f0, 1.0f, lOrVDotH);
        }

        /// <summary>
        /// Calculate a Schlick approximation to Fresnel with f0, f90
        /// </summary>
        float3 FresnelSchlick(float3 f0, float3 f90, float lOrVDotH)
        {
            return f0 + (f90 - f0) * pow((1-lOrVDotH), 5);
        }

        // -------------------------------------------------
        // Geometric Shadowing Functions
        // -------------------------------------------------
        // Expected parameters:
        //    alphaR = roughness^2 (Burley)
        //    nDotV  = max(dot(n, v), 1e-5f)
        //    nDotL  = saturate(dot(n, l))
        //    nDotH  = saturate(dot(n, h))
        // -------------------------------------------------
        
        /// <summary>
        /// Calculate the Implicit Geometric Shadowing
        /// </summary>
        float GeometricShadowingImplicit(float nDotL, float nDotV)
        {
            return nDotL * nDotV;
        }

        /// <summary>
        /// Calculate the Neumann Geometric Shadowing
        /// </summary>
        float GeometricShadowingNeumann(float nDotL, float nDotV)
        {
            return (nDotL * nDotV)/max(nDotL, nDotV);
        }

        /// <summary>
        /// Calculate the Cook-Torrance Geometric Shadowing
        /// </summary>
        float GeometricShadowingCookTorrance(float nDotH, float vDotH, float nDotL, float nDotV)
        {
            return min(1, min(2 * nDotH * nDotV / vDotH, 2 * nDotH * nDotL / vDotH));
        }

        /// <summary>
        /// Calculate the Kelemen Geometric Shadowing
        /// </summary>
        float GeometricShadowingKelemen(float vDotH, float nDotL, float nDotV)
        {
            return nDotL * nDotV / (vDotH * vDotH);
        }

        float GeometricShadowingBeckmann(float alphaR, float nDotX)
        {
            float c = nDotX / (alphaR * sqrt(1 - nDotX * nDotX));
            return c < 1.6f ? (3.535f * c + 2.181f * c * c) / ( 1 + 2.276f * c + 2577 * c * c) : 1.0f;
        }

        /// <summary>
        /// Calculate the Smith-Beckmann Geometric Shadowing (to use with their respective NDF)
        /// </summary>
        float GeometricShadowingSmithBeckmann(float alphaR, float nDotL, float nDotV)
        {
            return GeometricShadowingBeckmann(alphaR, nDotL) * GeometricShadowingBeckmann(alphaR, nDotV);
        }

        float GeometricShadowingGGXCorrelated(float alphaR, float nDotX)
        {
            var alphaR2 = alphaR * alphaR;
            var nDotX2 = nDotX * nDotX;
            return sqrt(1 + alphaR2 * ( 1 - nDotX2) / nDotX2);
        }

        /// <summary>
        /// Calculate the Smith-GGX Correlated Geometric Shadowing
        /// </summary>
        /// <remarks>See Moving Frostbite to PBR. SmithGGX Correlated</remarks>
        float GeometricShadowingSmithGGXCorrelated(float alphaR, float nDotL, float nDotV)
        {
            return 2.0f / ( GeometricShadowingGGXCorrelated(alphaR, nDotL) + GeometricShadowingGGXCorrelated(alphaR, nDotV));
        }

        float GeometricShadowinghSchlickBeckmann(float alphaR, float nDotX)
        {
            var k = alphaR * sqrt(2.0f / PI);
            return nDotX / (nDotX * (1 - k) + k);
        }

        /// <summary>
        /// Calculate the Smith-Schlick-Beckmann Geometric Shadowing
        /// </summary>
        float GeometricShadowingSmithSchlickBeckmann(float alphaR, float nDotL, float nDotV)
        {
            return GeometricShadowinghSchlickBeckmann(alphaR, nDotL) * GeometricShadowinghSchlickBeckmann(alphaR, nDotV);
        }

        float GeometricShadowinghSchlickGGX(float alphaR, float nDotX)
        {
            var k = alphaR * 0.5f;
            return nDotX / (nDotX * (1.0f - k) + k);
        }

        /// <summary>
        /// Calculate the Smith-Schlick-GGX Geometric Shadowing
        /// </summary>
        float GeometricShadowingSmithSchlickGGX(float alphaR, float nDotL, float nDotV)
        {
            return GeometricShadowinghSchlickGGX(alphaR, nDotL) * GeometricShadowinghSchlickGGX(alphaR, nDotV);
        }
    };
}