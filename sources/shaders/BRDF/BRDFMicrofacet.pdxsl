// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
namespace SiliconStudio.Paradox.Effects.BRDF
{
    /// <summary>
    /// Utility class for calculating the various variations of the functions 
    /// (Fresnel, NDF and Visibility) involved in a Microfacet shading model.
    /// </summary>
    class BRDFMicrofacet : Math
    {
        // References:
        // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html
        // TODO: Add reference to original papers here

        // -------------------------------------------------
        // Normal Distribution Functions
        // -------------------------------------------------
        // Expected parameters:
        //    alphaR = roughness^2 (Burley)
        //    nDotH  = saturate(dot(n, h))
        // -------------------------------------------------
        // TODO Add GGX Anisotropic

        /// <summary>
        /// Calculate the NDF Blinn-Phong
        /// </summary>
        float NormalDistributionBlinnPhong(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            return pow(nDotH, 2/alphaR2 - 2) / (PI * alphaR2);
        }

        /// <summary>
        /// Calculate the NDF Beckmann
        /// </summary>
        float NormalDistributionBeckmann(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            var nDotH2 =  nDotH * nDotH;
            var nDotH4 =  nDotH2 * nDotH2;
            return exp((nDotH2 -1)/(alphaR2 * nDotH2))/(PI * alphaR2 * nDotH4);
        }

        /// <summary>
        /// Calculate the NDF GGX
        /// </summary>
        float NormalDistributionGGX(float alphaR, float nDotH) 
        {
            var alphaR2 =  alphaR * alphaR;
            return alphaR2 / (PI * pow(nDotH * nDotH * (alphaR2 - 1) + 1, 2.0f));
        }

        // -------------------------------------------------
        // Fresnel Functions
        // -------------------------------------------------
        // Expected parameters:
        //    f0 = fresnel specular color at angle 0
        //    vDotH  = saturate(dot(v, h))
        // -------------------------------------------------

        /// <summary>
        /// Calculate a nop Fresnel.
        /// </summary>
        float3 FresnelNone(float3 f0)
        {
            return f0;
        }

        /// <summary>
        /// Calculate a Schlick approximation to Fresnel 
        /// </summary>
        float3 FresnelSchlick(float3 f0, float lOrVDotH)
        {
            return FresnelSchlick(f0, 1.0f, lOrVDotH);
        }

        /// <summary>
        /// Calculate a Schlick approximation to Fresnel with f0, f90
        /// </summary>
        float3 FresnelSchlick(float3 f0, float3 f90, float lOrVDotH)
        {
            return f0 + (f90 - f0) * pow((1-lOrVDotH), 5);
        }

        // -------------------------------------------------
        // Geometric Shadowing Functions
        // -------------------------------------------------
        // We are using V (Visibility) instead of G (Geometric Shadowing function)
        // The formula for V is given by:
        //    V = G / (nDotL * nDotV)
        //
        // Expected parameters:
        //    alphaR = roughness^2 (Burley)
        //    nDotV  = max(dot(n, v), 1e-5f)
        //    nDotL  = saturate(dot(n, l))
        //    nDotH  = saturate(dot(n, h))
        // -------------------------------------------------
        
        /// <summary>
        /// Calculate the Implicit Geometric Shadowing
        /// </summary>
        float VisibilityImplicit(float nDotL, float nDotV)
        {
            // G = nDotL * nDotV
            return 1.0f;
        }

        /// <summary>
        /// Calculate the Neumann Geometric Shadowing
        /// </summary>
        float VisibilityNeumann(float nDotL, float nDotV)
        {
            // G = (nDotL * nDotV) / max(nDotL, nDotV) 
            return 1.0 / max(nDotL, nDotV);
        }

        /// <summary>
        /// Calculate the Cook-Torrance Geometric Shadowing
        /// </summary>
        float VisibilityCookTorrance(float nDotH, float vDotH, float nDotL, float nDotV)
        {
            // G = min(1, min(2 * nDotH * nDotV / vDotH, 2 * nDotH * nDotL / vDotH));
            return min(1, min(2 * nDotH * nDotV / vDotH, 2 * nDotH * nDotL / vDotH)) / (nDotL * nDotV);
        }

        /// <summary>
        /// Calculate the Kelemen Geometric Shadowing
        /// </summary>
        float VisibilityKelemen(float vDotH, float nDotL, float nDotV)
        {
            // G = nDotL * nDotV / (vDotH * vDotH);
            return 1.0f / (vDotH * vDotH);
        }

        float VisibilityBeckmann(float alphaR, float nDotX)
        {
            float c = nDotX / (alphaR * sqrt(1 - nDotX * nDotX));
            return c < 1.6f ? (3.535f * c + 2.181f * c * c) / ( 1 + 2.276f * c + 2577 * c * c) : 1.0f;
        }

        /// <summary>
        /// Calculate the Smith-Beckmann Geometric Shadowing (to use with their respective NDF)
        /// </summary>
        float VisibilitySmithBeckmann(float alphaR, float nDotL, float nDotV)
        {
            return (VisibilityBeckmann(alphaR, nDotL) * VisibilityBeckmann(alphaR, nDotV)) / (nDotL * nDotV);
        }

        float VisibilityGGXCorrelated(float alphaR, float nDotX)
        {
            var alphaR2 = alphaR * alphaR;
            var nDotX2 = nDotX * nDotX;
            return sqrt(1 + alphaR2 * ( 1 - nDotX2) / nDotX2);
        }

        /// <summary>
        /// Calculate the Smith-GGX Correlated Geometric Shadowing
        /// </summary>
        /// <remarks>See Moving Frostbite to PBR. SmithGGX Correlated</remarks>
        float VisibilitySmithGGXCorrelated(float alphaR, float nDotL, float nDotV)
        {
            // TODO: Expand (nDotL * nDotV)
            return 2.0f / ( VisibilityGGXCorrelated(alphaR, nDotL) + VisibilityGGXCorrelated(alphaR, nDotV)) / (nDotL * nDotV);
        }

        float VisibilityhSchlickBeckmann(float alphaR, float nDotX)
        {
            var k = alphaR * sqrt(2.0f / PI);
            return nDotX / (nDotX * (1 - k) + k);
        }

        /// <summary>
        /// Calculate the Smith-Schlick-Beckmann Geometric Shadowing
        /// </summary>
        float VisibilitySmithSchlickBeckmann(float alphaR, float nDotL, float nDotV)
        {
            return VisibilityhSchlickBeckmann(alphaR, nDotL) * VisibilityhSchlickBeckmann(alphaR, nDotV) / (nDotL * nDotV);
        }

        float VisibilityhSchlickGGX(float alphaR, float nDotX)
        {
            var k = alphaR * 0.5f;
            return nDotX / (nDotX * (1.0f - k) + k);
        }

        /// <summary>
        /// Calculate the Smith-Schlick-GGX Geometric Shadowing
        /// </summary>
        float VisibilitySmithSchlickGGX(float alphaR, float nDotL, float nDotV)
        {
            return VisibilityhSchlickGGX(alphaR, nDotL) * VisibilityhSchlickGGX(alphaR, nDotV) / (nDotL * nDotV);
        }
    };
}