// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
using SiliconStudio.Paradox.Effects.Data;
using SiliconStudio.Paradox.Effects;
using SiliconStudio.Paradox.Effects.Materials;

namespace SiliconStudio.Paradox.Effects
{
    /// <summary>
    /// Base shader
    /// </summary>
    partial shader ParadoxBaseShader
    {
        using params LightingKeys;
        using params MaterialParameters;
        using params MaterialKeys;

        mixin ShaderBase;
        mixin ShadingBase;
        mixin NormalStream;
        mixin TransformationWAndVP;
        mixin PositionVSStream;

        // -----------------------------------------------
        // Performs normal mapping (in case of no-skinning, otherwise it is overloaded below)
        // -----------------------------------------------
        if (MaterialParameters.HasNormalMap)
        {
            mixin NormalVSFromNormalMapping;
        }
        else
        {
            mixin NormalVSFromMesh;
        }

        // -----------------------------------------------
        // Performs animation skinning (position, normal and tangent)
        // -----------------------------------------------
        //if (MaterialParameters.HasSkinningPosition)
        if (false)
        {
            if (MaterialParameters.SkinningBones > MaterialParameters.SkinningMaxBones)
            {
                // TODO: We should use next power of two minus constant to limit shader permutations?
                MaterialParameters.SkinningMaxBones = MaterialParameters.SkinningBones;
            }
            mixin macro MaterialParameters.SkinningMaxBones;
            mixin TransformationSkinning;

            if (MaterialParameters.HasSkinningNormal)
            {
                mixin NormalMeshSkinning;
            }

            if (MaterialParameters.HasSkinningTangent)
            {
                mixin TangentMeshSkinning;
            }

            if (MaterialParameters.HasSkinningNormal)
            {
                if (MaterialParameters.HasNormalMap)
                {
                    mixin NormalVSSkinningNormalMapping;
                }
                else
                {
                    mixin NormalVSSkinningFromMesh;
                }
            }
        }

        // -----------------------------------------------
        // Mix material and lighting shading for Pixel Shader
        // -----------------------------------------------
        if (MaterialKeys.PixelStageSurfaceShaders != null)
        {
            mixin MaterialSurfacePixelStageCompositor;
            mixin compose materialPixelStage = MaterialKeys.PixelStageSurfaceShaders;
        }

        // -----------------------------------------------
        // Add light groups
        // -----------------------------------------------
        var directLightGroups = LightingKeys.DirectLightGroups;
        if (directLightGroups != null)
        {
            foreach(var directLightGroup in directLightGroups)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose directLightGroups += (directLightGroup);
            }
        }

        // -----------------------------------------------
        // Add environment light groups
        // -----------------------------------------------
        var environmentLights = LightingKeys.EnvironmentLights;
        if (environmentLights != null)
        {
            foreach(var environmentLight in environmentLights)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose environmentLights += (environmentLight);
            }
        }

        // -----------------------------------------------
        // Mix ShadowMap caster 
        // -----------------------------------------------
        if (LightingKeys.CastShadows)
            mixin child ShadowMapCaster;

    };
}