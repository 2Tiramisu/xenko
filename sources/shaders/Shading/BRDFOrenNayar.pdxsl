// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
/// <summary>
/// Computes a diffuse color based on Oren-Nayar model.
/// </summary>
class BRDFOrenNayar
{
    // suppose normalized vectors
    float Compute(float3 L, float3 N, float3 V, float roughness)
    {
        float squaredRough = roughness * roughness;
        float A = 1 - (0.5 * squaredRough / (squaredRough + 0.33));
        float B = 0.45 * squaredRough / (squaredRough + 0.09);
        
        // force in [-1,1] -> clamp
        // saturate should be enough because a negative cosine means a back face
        float NdotL = saturate(dot(N, L));
        float NdotV = saturate(dot(N, V));
        float sinThetaI = saturate(length(cross(N, V)));
        float sinThetaR = saturate(length(cross(N, L)));
        float sinAlpha = 0;
        float tanBeta = 0;
        
        float3 dI = L - NdotL * N;
        float3 dR = V - NdotV * N;
        float cosPhi = max(0, dot(dI,dR));
        
        // ThetaI and ThetaR in [0, PI] where cosine is a decreasing function
        if (NdotL < NdotV)
        {
            sinAlpha = sinThetaI;
            tanBeta = sinThetaR / NdotV;
        }
        else
        {
            sinAlpha = sinThetaR;
            tanBeta = sinThetaI / NdotL;
        }
        
        return (A + (B * cosPhi * sinAlpha * tanBeta));
    }
};
