<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var nodeTypes = new[] { "ViewObject", "Object", "Render", "EffectObject", "View", "EffectView", "StaticObject", "StaticEffectObject" }; #>
namespace SiliconStudio.Xenko.Rendering
{
    public enum DataType
    {
<# foreach (var type in nodeTypes) { #>
        <#= type #>,
<# } #>
    }

<# foreach (var type in nodeTypes) { #>
    public struct <#=type#>PropertyData<T>
    {
        internal T[] Data;

        internal <#=type#>PropertyData(T[] data)
        {
            Data = data;
        }

        internal T this[<#=type#>NodeReference index]
        {
            get { return Data[index.Index]; }
            set { Data[index.Index] = value; }
        }
    }

	public struct <#=type#>PropertyKey<T>
    {
        internal readonly int Index;

        internal <#=type#>PropertyKey(int index)
        {
            Index = index;
        }
    }

	public class <#=type#>PropertyDefinition<T>
    {
    }

	partial struct <#=type#>NodeReference
    {
        internal readonly int Index;

        /// <summary>
        /// Invalid slot.
        /// </summary>
		public static readonly <#=type#>NodeReference Invalid = new <#=type#>NodeReference(-1);

        internal <#=type#>NodeReference(int index)
        {
            Index = index;
        }

        public static bool operator ==(<#=type#>NodeReference a, <#=type#>NodeReference b)
        {
            return a.Index == b.Index;
        }

		public static bool operator !=(<#=type#>NodeReference a, <#=type#>NodeReference b)
        {
            return a.Index != b.Index;
        }
    }

	partial class RootRenderFeature
	{
        internal <#=type#>PropertyKey<T> Create<#=type#>Key<T>(<#=type#>PropertyDefinition<T> definition = null)
        {
            if (definition != null)
            {
                int existingIndex;
                if (dataArraysByDefinition.TryGetValue(definition, out existingIndex))
                    return new <#=type#>PropertyKey<T>(existingIndex);

                dataArraysByDefinition.Add(definition, dataArrays.Count);
            }

            var dataArraysIndex = dataArrays.Count;
			dataArrays.Add(new DataArray(new DataArrayInfo<T>(DataType.<#=type#>)));
            return new <#=type#>PropertyKey<T>(dataArraysIndex);
        }

		internal <#=type#>PropertyData<T> GetData<T>(<#=type#>PropertyKey<T> key)
        {
            return new <#=type#>PropertyData<T>((T[])dataArrays[key.Index].Array);
        }
	}
<# } #>
}