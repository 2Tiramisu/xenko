using SiliconStudio.Xenko.Rendering;
using SiliconStudio.Xenko.Rendering.Materials;

namespace SiliconStudio.Xenko.Engine.NextGen.Effects
{
    shader TestEffect
    {
        using params LightingKeys;
        using params MaterialKeys;

        // -----------------------------------------------
        // Transform vertex stream
        // -----------------------------------------------
        // Come after material surface per vertex
        mixin TransformationBase;
        mixin NormalStream;
        mixin TransformationWAndVP;

        // -----------------------------------------------
        // Performs normal mapping (in case of no-skinning, otherwise it is overloaded below)
        // -----------------------------------------------
        if (MaterialKeys.HasNormalMap)
        {
            mixin NormalFromNormalMapping;
        }
        else
        {
            mixin NormalFromMesh;
        }

        // -----------------------------------------------
        // Performs animation skinning (position, normal and tangent)
        // -----------------------------------------------
        if (MaterialKeys.HasSkinningPosition)
        {
            mixin macro MaterialKeys.SkinningMaxBones;
            mixin TransformationSkinning;

            if (MaterialKeys.HasSkinningNormal)
            {
                mixin NormalMeshSkinning;
            }

            if (MaterialKeys.HasSkinningTangent)
            {
                mixin TangentMeshSkinning;
            }

            if (MaterialKeys.HasSkinningNormal)
            {
                if (MaterialKeys.HasNormalMap)
                {
                    mixin NormalVSSkinningNormalMapping;
                }
                else
                {
                    mixin NormalVSSkinningFromMesh;
                }
            }
        }

        //mixin TestShader;

        // -----------------------------------------------
        // Mix material and lighting shading for Pixel Shader
        // -----------------------------------------------
        var extensionPixelStageSurfaceShaders = MaterialKeys.PixelStageSurfaceShaders;
        if (extensionPixelStageSurfaceShaders != null)
        {
            mixin MaterialSurfacePixelStageCompositor;
            mixin compose materialPixelStage = (extensionPixelStageSurfaceShaders);
            mixin compose streamInitializerPixelStage = MaterialKeys.PixelStageStreamInitializer;

            var extensionPixelStageSurfaceFilter = MaterialKeys.PixelStageSurfaceFilter;
            if (extensionPixelStageSurfaceFilter != null)
            {
                mixin (extensionPixelStageSurfaceFilter);
            }
        }

        // -----------------------------------------------
        // Add light groups
        // -----------------------------------------------
        var directLightGroups = LightingKeys.DirectLightGroups;
        if (directLightGroups != null)
        {
            foreach(var directLightGroup in directLightGroups)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose directLightGroups += (directLightGroup);
            }
        }

        // -----------------------------------------------
        // Add environment light groups
        // -----------------------------------------------
        var environmentLights = LightingKeys.EnvironmentLights;
        if (environmentLights != null)
        {
            foreach(var environmentLight in environmentLights)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose environmentLights += (environmentLight);
            }
        }

        mixin child GBuffer;
        mixin child ShadowMapCaster;
        mixin child Picking;
        mixin child Wireframe;
        mixin child Highlight;
    }

    shader Wireframe
    {
        using params MaterialFrontBackBlendShaderKeys;

        mixin MaterialFrontBackBlendShader<MaterialFrontBackBlendShaderKeys.UseNormalBackFace>;
    }

    shader Highlight
    {
        mixin HighlightShader;
    }
}