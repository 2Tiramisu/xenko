// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Xenko.Rendering.Images
{

// TODO Need to blur once against neighbors in the first AO pass
#define     SCALE           (2)

/** Increase to make edges crisper. Decrease to reduce temporal flicker. */
#define     EDGE_SHARPNESS  (1.0)

    /// <summary>
    /// A gaussian blur shader
    /// </summary>
    internal shader AmbientOcclusionBlurShader<int BlurCount, bool IsVertical> : ImageEffectShader, Camera
    {
        stage float  Weights[BlurCount];

        stage float reconstructCSZ(float depth)
        {
            return ZProjection.y / (depth - ZProjection.x);
        }

        stage override float4 Shading()
        {
            const float epsilon = 0.0001;

            // Direction in texel size: (float2(1,0) or float2(0,1)) * texel size
            float2 direction = (IsVertical ? float2(0, 1) : float2(1, 0)) * Texture0TexelSize;

            // Add center
            float totalWeight = Weights[0];
            float3 sum = Texture0.Sample(LinearSampler, streams.TexCoord).rgb * totalWeight;

            float linearDepth = reconstructCSZ(Texture1.Sample(LinearSampler, streams.TexCoord).x);
            if (linearDepth >= 300)
            {
                sum /= (totalWeight + epsilon);
                return float4(sum, 1);
            }

                // mirrored samples using bilinear filtering
            [
            unroll]
            for(int i = 1; i < BlurCount; i++)
            {
                // Handle both directions
                [unroll]
                for (int j = -1; j <= 1; j += 2)
                {
                    float weight = 0.3 + Weights[i];

                    float value = Texture0.Sample(LinearSampler, streams.TexCoord + direction * j * i * SCALE).rgb;

                    float linearDepthOther = reconstructCSZ(Texture1.Sample(LinearSampler, streams.TexCoord + direction * j * i * SCALE).x);
                    weight *= max(0.0, 1.0 - (1.0 * EDGE_SHARPNESS) * abs(linearDepth - linearDepthOther));

                    sum += value * weight;

                    totalWeight += weight;
                }
            }

            sum /= (totalWeight + epsilon);
            return float4(sum, 1);
        }
    };
}
