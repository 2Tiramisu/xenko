using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using SiliconStudio.Xenko.Rendering.Materials.ComputeColors;

#define NUM_SAMPLES         9   // DONE
#define NUM_SPIRAL_TURNS    7
#define MAX_MIP_LEVEL       5
#define LOG_MAX_OFFSET      3

namespace SiliconStudio.Xenko.Rendering.Images
{
    shader ReconstructCameraSpaceZ : ImageEffectShader, Camera
    {
        // TODO WorldViewProjection matrix

        float4x4 InverseProjection;
        float4x4 InverseView;
        float4x4 InverseViewProjection;
        float4   ProjInfo;    // .x = zN * zF, .y = zN - zF, .z = zF
        float4   ScreenInfo;  // .x = Width, .y = Height, .z = Aspect

//        float    projScale = 500;
//        float    radius = 1;
//        float    radiusSquared = 1;
//        float    bias = 0.01f;
//        float    intensity = 1;

        stage float reconstructCSZ(float depth)
        {
            // ZProjection is defined in Camera.xksl
            return ZProjection.y / (depth - ZProjection.x);
        }

        stage float3 reconstructCSPosition(float2 S, float z)
        {
            return float3((S.xy * ProjInfo.xy + ProjInfo.zw) * z, z);
        }

        stage float3 reconstructCSNormal(float3 position)
        {
            return normalize(cross(ddy(position), ddx(position)));
        }

        stage float2 sampleOffset(int sampleCount, float angle, out float screenSpaceRadius)
        {
         //   float alpha = 0.1 * (i + 0.5) * 0.675f / NUM_SAMPLES;
          //  angle = 2 * 43.9822971503f * alpha + angle;

            float alpha = (sampleCount + 0.5) * 0.11111 /*(1.0 / NUM_SAMPLES)*/;
            angle += alpha * 43.9822971503 /*(NUM_SPIRAL_TURNS * 6.28)*/;

            screenSpaceRadius = alpha;
            return float2(cos(angle), sin(angle));
        }

        stage float3 getOffsetPosition(int2 screenPos, float2 offset, float radius)
        {
            int mipLevel = clamp((int)floor(log2(radius)) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);

            int2 samplePos = int2(offset * radius) + screenPos;
            samplePos.x = screenPos.x + (offset.x * radius);
            samplePos.y = screenPos.y + (offset.y * radius);

            float2 samplePosFloat = (offset.xy / ScreenInfo.xy) * radius;

            //float depth = Texture1.Load(int3(samplePos >> mipLevel, mipLevel));
            float depth = Texture1.SampleLevel(Sampler, streams.TexCoord + samplePosFloat, 0).x;

            float linearDepth = reconstructCSZ(depth);

            float3 position = reconstructCSPosition(samplePos + float2(0.5, 0.5), linearDepth);

            return position;
        }

        stage float sampleAO(int2 screenPosition, float3 viewPosition, float3 viewNormal, float diskRadius, float i, float randomPatternRotationAngle)
        {
            float ssRadius;
            float2 offset = sampleOffset(i, randomPatternRotationAngle, ssRadius);
            ssRadius *= diskRadius;

            float3 pos = getOffsetPosition(screenPosition, offset, ssRadius);

            float3 v = pos - viewPosition;

            float vv = dot(v, v);
            float vn = dot(v, viewNormal);

            const float epsilon = 0.01;

            float f = max(1 /*radiusSquared*/ - vv, 0.0);
            return f * f * f * max((vn - 0.01 /*bias*/) / (epsilon + vv), 0.0);

        }



        stage float sampleAODebug(int2 screenPosition, float3 viewPosition, float3 viewNormal, float diskRadius, int i, float randomPatternRotationAngle)
        {
            //*****************************
            //  Sample Offset
            float alpha = 0.1 * (i + 0.5) * 0.675f / NUM_SAMPLES;
            float angle = 2 * 43.9822971503f * alpha + randomPatternRotationAngle;

            float2 offset = float2(cos(angle), sin(angle));
            float ssRadius = alpha * diskRadius;

            //*****************************
            //  Depth
            float2 samplePos = streams.TexCoord + offset * ssRadius;
            float depth = Texture1.SampleLevel(Sampler, samplePos, 0).x;
            float linearDepth = reconstructCSZ(depth);

            //*****************************
            // View Position
            float3 position = reconstructCSPosition(samplePos * ScreenInfo.xy + float2(0.5, 0.5), linearDepth);
                   position.x *= -1;


            //*****************************
            // Ambient Occlusion
            float3 v = position - viewPosition;

           // return position.x;

            float distSq = dot(v, v);
//            float vn = max(0, dot(v, viewNormal));
            float vn = dot(v, viewNormal);

            const float epsilon = 0.01;

            //return vn.x;

            float maxRadiusSq = 1;  // radiusSquared
            float f = max(maxRadiusSq - distSq, 0.0);

            return f * f * f * max((vn - 0.01 /*bias*/) / (epsilon + distSq), 0.0);

        }

        stage override float4 Shading()
        {
            // Reconstruct View space linear depth Z from the depth buffer
            float depth = Texture1.SampleLevel(Sampler, streams.TexCoord, 0).x;
            float linearDepth = reconstructCSZ(depth);

            // Reconstruct View space position XYZ
            int2 screenPosition = streams.TexCoord.xy * ScreenInfo.xy;
            float3 viewPosition = reconstructCSPosition(screenPosition + float2(0.5, 0.5), linearDepth);
                   viewPosition.x *= -1;

            // Reconstruct View space normal NxNyNz
            float3 viewNormal = reconstructCSNormal(viewPosition.xyz);
                   viewNormal.xy *= -1;


            // Hash function used in the HPG12 AlchemyAO paper
            float randomPatternRotationAngle = (3 * screenPosition.x ^ screenPosition.y + screenPosition.x * screenPosition.y) * 10;

            // Choose a sample radius proportional to the projected area of the half-sphere
            //float diskRadius = -projScale * radius / linearDepth;
            float diskRadius = 1.0f / linearDepth;

            // Compute the ambient occlusion
            float sum = 0.0;
            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                //sum += sampleAO(screenPosition, viewPosition, viewNormal, diskRadius, i, randomPatternRotationAngle);
                sum += sampleAODebug(screenPosition, viewPosition, viewNormal, diskRadius, i, randomPatternRotationAngle);
            }

            float temp = 1 /*radiusSquared*/ * 1 /*radius*/;
            sum /= temp * temp;
	        float A = max(0.0, 1.0 - sum * 0.1 /*intensity*/ * (5.0 / NUM_SAMPLES));


            // DEBUG
            // DEBUG
            // DEBUG
            /*
            sum = 0.0;
            for (int i = 0; i < 9; i++)
            {
                sum += sampleAODebug(screenPosition, viewPosition, viewNormal, diskRadius, i, randomPatternRotationAngle);
            }
            sum /= 9;
            //*/
            // DEBUG
            // DEBUG
            // DEBUG


            // Bilateral box-filter over a quad for free, respecting depth edges
	        // (the difference that this makes is subtle)
	
            //*
            if (abs(ddx(linearDepth)) < 0.02)
            {
		        A -= ddx(A) * ((screenPosition.x & 1) - 0.5);
	        }
	        if (abs(ddy(linearDepth)) < 0.02)
            {
                A -= ddy(A) * ((screenPosition.y & 1) - 0.5);
	        }
            //*/


            //************************
            // Debug - visualize different
            //************************

            /************************
            // Visualize depth as color bands
            //************************
            linearDepth = sum;
            float4 color = Texture0.Sample(Sampler, streams.TexCoord);
            color.r = ((float)(linearDepth % 4)) / 4.0;
            color.g = ((float)((linearDepth / 4) % 4)) / 4.0;
            color.b = ((float)((linearDepth / 16) % 4)) / 4.0;
            return color; //*/

            //************************
            // Visualize depth as view space position OR view space normal
            //************************
            float4 color = Texture0.Sample(Sampler, streams.TexCoord);
            color.rgb = viewNormal.xyz;

            color.rgb = A;
//            color.g = sum;
//            color.r = diskRadius;
            return color; //*/

        }

    };
}
