using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using SiliconStudio.Xenko.Rendering.Materials.ComputeColors;

#define NUM_SAMPLES         9   // DONE
#define NUM_SPIRAL_TURNS    7
#define MAX_MIP_LEVEL       5
#define LOG_MAX_OFFSET      3

namespace SiliconStudio.Xenko.Rendering.Images
{
    shader ReconstructCameraSpaceZ : ImageEffectShader, Camera
    {
        // TODO WorldViewProjection matrix

        float4x4 InverseProjection;
        float4x4 InverseView;
        float4x4 InverseViewProjection;
        float4   ProjInfo;    // .x = zN * zF, .y = zN - zF, .z = zF
        float4   ScreenInfo;  // .x = Width, .y = Height, .z = Aspect

        float    ParamProjScale = 1;
        float    ParamIntensity = 1;
        float    ParamBias = 0.01f;
        float    ParamRadius = 1;
        float    ParamRadiusSquared = 1;

        stage float reconstructCSZ(float depth)
        {
            // ZProjection is defined in Camera.xksl
            return ZProjection.y / (depth - ZProjection.x);
        }

        stage float3 reconstructCSPosition(float2 S, float z)
        {
            return float3((S.xy * ProjInfo.xy + ProjInfo.zw) * z, z);
        }

        stage float3 reconstructCSNormal(float3 position)
        {
            return normalize(cross(ddy(position), ddx(position)));
        }

        stage float2 sampleOffset(int sampleCount, float angle, out float screenSpaceRadius)
        {
         //   float alpha = 0.1 * (i + 0.5) * 0.675f / NUM_SAMPLES;
          //  angle = 2 * 43.9822971503f * alpha + angle;

            float alpha = (sampleCount + 0.5) * 0.11111 /*(1.0 / NUM_SAMPLES)*/;
            angle += alpha * 43.9822971503 /*(NUM_SPIRAL_TURNS * 6.28)*/;

            screenSpaceRadius = alpha;
            return float2(cos(angle), sin(angle));
        }

        stage float3 getOffsetPosition(int2 screenPos, float2 offset, float radius)
        {
            int mipLevel = clamp((int)floor(log2(radius)) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);

            int2 samplePos = int2(offset * radius) + screenPos;
            samplePos.x = screenPos.x + (offset.x * radius);
            samplePos.y = screenPos.y + (offset.y * radius);

            float2 samplePosFloat = (offset.xy / ScreenInfo.xy) * radius;

            //float depth = Texture1.Load(int3(samplePos >> mipLevel, mipLevel));
            float depth = Texture1.SampleLevel(Sampler, streams.TexCoord + samplePosFloat, 0).x;

            float linearDepth = reconstructCSZ(depth);

            float3 position = reconstructCSPosition(samplePos + float2(0.5, 0.5), linearDepth);

            return position;
        }

        stage float sampleAO(int2 screenPosition, float3 viewPosition, float3 viewNormal, float diskRadius, float i, float randomPatternRotationAngle)
        {
            float ssRadius;
            float2 offset = sampleOffset(i, randomPatternRotationAngle, ssRadius);
            ssRadius *= diskRadius;

            float3 pos = getOffsetPosition(screenPosition, offset, ssRadius);

            float3 v = pos - viewPosition;

            float vv = dot(v, v);
            float vn = dot(v, viewNormal);

            const float epsilon = 0.01;

            float f = max(1 /*radiusSquared*/ - vv, 0.0);
            return f * f * f * max((vn - 0.01 /*bias*/) / (epsilon + vv), 0.0);
        }



        stage float sampleAODebug(int2 screenPosition, float3 viewPosition, float3 viewNormal, float diskRadius, int i, float randomPatternRotationAngle)
        {
            //*****************************
            //  Sample Offset
            float alpha = 1 * (i + 0.5) * 0.675f / NUM_SAMPLES;
            float angle = 2 * 43.9822971503f * alpha + randomPatternRotationAngle;

            float2 offset = float2(cos(angle), sin(angle));
            float ssRadius = alpha * diskRadius;

            //*****************************
            //  Depth
            float2 samplePos = streams.TexCoord + offset * ssRadius;

            int2 samplePosInt = screenPosition + int2(ScreenInfo.xy * offset * ssRadius);
            if (samplePosInt.x < 0 || samplePosInt.y < 0 || samplePosInt.x >= ScreenInfo.x || samplePosInt.y >= ScreenInfo.y)
                return 0;

            float depth = Texture1.Load(int3(samplePosInt, 0));

            float linearDepth = reconstructCSZ(depth);

//            if (linearDepth >= viewPosition.z)
//                return 0;

            //*****************************
            // View Position
            float3 position = reconstructCSPosition(samplePosInt + float2(0.5, 0.5), linearDepth);
                   position.x *= -1;

            //*****************************
            // View Normal
            float3 v = position - viewPosition;
            v.z *= -1;
            
            //*****************************
            // Ambient Occlusion
            float distSq = dot(v, v);
            float vn = dot(v, viewNormal);

            const float epsilon = 0.01;


            return max((vn - 0.01 /*bias*/)/(epsilon + distSq), 0.0);

            float maxRadiusSq = 1;  // radiusSquared
            float f = max(maxRadiusSq - distSq, 0.0);

            return f * f * f * max((vn - 0.01 /*bias*/) / (epsilon + distSq), 0.0);

        }

        stage override float4 Shading()
        {
            // Reconstruct View space linear depth Z from the depth buffer
            float depth = Texture1.SampleLevel(Sampler, streams.TexCoord, 0).x;
            float linearDepth = reconstructCSZ(depth);

            // Reconstruct View space position XYZ
            int2 screenPosition = streams.TexCoord.xy * ScreenInfo.xy;
            float3 viewPosition = reconstructCSPosition(screenPosition + float2(0.5, 0.5), linearDepth);
                   viewPosition.x *= -1;

            // Reconstruct View space normal NxNyNz
            float3 viewNormal = reconstructCSNormal(viewPosition.xyz);
                   viewNormal.xy *= -1;


            // Hash function used in the HPG12 AlchemyAO paper
            float randomPatternRotationAngle = (3 * screenPosition.x ^ screenPosition.y + screenPosition.x * screenPosition.y) * 10;

            // Choose a sample radius proportional to the projected area of the half-sphere
            //float diskRadius = -projScale * radius / linearDepth;
            float diskRadius = 1.0f / linearDepth;

            // Compute the ambient occlusion
            float sum = 0.0;
            for (int i = 0; i < NUM_SAMPLES; i++)
            {
                //sum += sampleAO(screenPosition, viewPosition, viewNormal, diskRadius, i, randomPatternRotationAngle);
                sum += sampleAODebug(screenPosition, viewPosition, viewNormal, diskRadius, i, randomPatternRotationAngle);
            }

            float temp = 1 /*radiusSquared*/ * 1 /*radius*/;
            sum /= temp * temp;
	        float A = max(0.0, 1.0 - sum * 0.2f /*intensity*/ * (5.0 / NUM_SAMPLES));


            // Bilateral box-filter over a quad for free, respecting depth edges
	        // (the difference that this makes is subtle)
            if (abs(ddx(linearDepth)) < 0.02)
            {
		        A -= ddx(A) * ((screenPosition.x & 1) - 0.5);
	        }
	        if (abs(ddy(linearDepth)) < 0.02)
            {
                A -= ddy(A) * ((screenPosition.y & 1) - 0.5);
	        }

            //************************
            // A now contains the light intensity factor (0 to 1) which can be applied to the ambient light illuminating the pixel



            //************************
            // Debug - visualize different
            //************************

            /************************
            // Visualize depth as color bands
            //************************
            linearDepth = sum;
            float4 color = Texture0.Sample(Sampler, streams.TexCoord);
            color.r = ((float)(linearDepth % 4)) / 4.0;
            color.g = ((float)((linearDepth / 4) % 4)) / 4.0;
            color.b = ((float)((linearDepth / 16) % 4)) / 4.0;
            return color; //*/


            //************************
            // Visualize depth as view space position OR view space normal
            //************************
            float4 color = Texture0.Sample(Sampler, streams.TexCoord);
            color.rgb = viewNormal.xyz;

            color.rgb *= A;
//            color.g = sum;
//            color.r = diskRadius;
            return color; //*/

        }

    };
}
