// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.

namespace SiliconStudio.Paradox.Effects.Images
{

    /// <summary>
    /// A blur with weights applied along one direction. 
    /// The blurring algorithm is also depth-aware: sample weights are modified on-the-fly to avoid 
    /// artifacts such as in-focus objects bleeding into out-of-focus background objects.
    /// Expects as input: 
    /// - Texture0: color buffer
    /// </summary>
    ///
    /// <typeparam name="TWeightCount">The number of weights along a direction.</typeparam>
    /// <typeparam name="TTotalNumber">Total number of tpas. The value is always 2 * TWeightCount - 1.</typeparam>

    class DepthAwareDirectionalBlurUtil<int TWeightCount, int TTotalNumber> : Texturing, ComputeColor
    {
        // Direction to apply the blur. (normalized vector)
        float2 Direction;

        // The radius of the blur to apply around the considered fragment
        float Radius;

        // Weights of each tap (weights values are symmetric along each direction)
        float TapWeights[TWeightCount];

        float CoCReference;

        // Gets the blur result for the current pixel.
        override float4 Compute()
        {
            // Offset between 2 consecutive taps
            float2 tapOffset =  Radius / (TWeightCount - 1) * Texture0TexelSize;
            
            // Fills arrays with all the taps
            float4 tapColor[TTotalNumber];  // All the taps colors
            float tapOriginalWeight[TTotalNumber]; // With their respective weight

            // Center tap
            int centerIndex = TWeightCount - 1;
            tapColor[centerIndex] = Texture0.Sample(LinearSampler, streams.TexCoord).xyzw;
            tapOriginalWeight[centerIndex] = TapWeights[0];

            // Treats all the taps in the 2 directions from the center
            [unroll]
            for(int i = 1; i < TWeightCount; i++)
            {
                [unroll]
                for (int j = -1.0; j <= 1.0; j += 2) // Backward(-1) and forward(+1) along the direction
                {                     
                    float2 tapUV = streams.TexCoord + j * i * Direction * tapOffset;
                    int tapIndex = centerIndex + (j * i);
                    tapColor[tapIndex]          = Texture0.Sample(LinearSampler, tapUV).xyzw;
                    tapOriginalWeight[tapIndex] = TapWeights[i];
                }
            }

            // Calculate the final average color by modifying tap weights on-the-fly
            float3 resultColor = float3(0.0, 0.0, 0.0);
            float totalWeight = 0.0;

            [unroll]
            for(int k = 0; k < TTotalNumber; k++)
            {
                float contribution = tapColor[k].w; // alpha modulates the contribution
                // Final weight value to use
                float tapWeight = contribution * tapOriginalWeight[k];
                resultColor += tapColor[k].xyz /*  * tapColor[k].w */  * tapWeight;
                totalWeight += tapWeight;
            }

            if (totalWeight > 0) {
                // Normalizes the final result
                resultColor /= totalWeight;
            } else {
                resultColor = float3(0.0, 0.0, 0.0);
            }

            float finalWeight = 0;
            if (totalWeight > 0) finalWeight = 1.0 / totalWeight;

            return float4(resultColor, sign(totalWeight) );
        }
    };
}
