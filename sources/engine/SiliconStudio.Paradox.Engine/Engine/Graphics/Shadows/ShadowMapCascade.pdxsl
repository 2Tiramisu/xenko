// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
namespace SiliconStudio.Paradox.Effects.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    /// <remarks>
    /// TCascadeCount: Number of cascades.
    /// TCascadeDebug: Flag to enable debug mode (1 color per cascade).
    /// </remarks>
    internal class ShadowMapCascade<int TCascadeCount, int TLightCount, bool TBlendCascades, bool TCascadeDebug> : ShadowMapGroup, ShadowMapFilterBase, PositionStream4
    {
        cbuffer PerPass // TODO: Use a proper cbuffer for this?
        {
            float CascadeDepthSplits[TCascadeCount * TLightCount];
            float4x4 WorldToShadowCascadeUV[TCascadeCount * TLightCount];
        };

        float ComputeShadowFromCascade(float3 shadowPositionWS, int cascadeIndex, int lightIndex)
        {
            float3 shadowPosition = mul(float4(shadowPositionWS, 1), WorldToShadowCascadeUV[cascadeIndex + lightIndex * TCascadeCount]).xyz;
            return FilterShadow(shadowPosition.xy, shadowPosition.z);
        }

        override void ComputeShadow(int lightIndex)
        {
            base.ComputeShadow(lightIndex);

            // Only support a single light per group
            int cascadeIndex = 0;
            [unroll] 
            for(int i = 0; i < TCascadeCount - 1; i++) 
            {
                [flatten]
                if (streams.DepthVS > CascadeDepthSplits[i + lightIndex * TCascadeCount])
                {
                    cascadeIndex = i + 1;
                }
            }

            var shadow = ComputeShadowFromCascade(streams.PositionWS.xyz, cascadeIndex, lightIndex);

            if (TBlendCascades)
            {
                // Use blending technique from MJP
                const float BlendThreshold = 0.5f;
                float nextSplit = CascadeDepthSplits[cascadeIndex];
                float splitSize = cascadeIndex == 0 ? nextSplit : nextSplit - CascadeDepthSplits[cascadeIndex - 1];
                float splitDist = (nextSplit - streams.DepthVS) / splitSize;

                if(splitDist <= BlendThreshold && cascadeIndex != TCascadeCount - 1)
                {
                    float nextShadow = ComputeShadowFromCascade(streams.PositionWS.xyz, cascadeIndex + 1, lightIndex);
                    float lerpAmt = smoothstep(0.0f, 1.0f, splitDist / BlendThreshold);
                    shadow = lerp(nextShadow, shadow, lerpAmt);
                }
            }

            // Output the shadow color
            if (TCascadeDebug)
            {
                //// Display Cascade with colors in debug mode
                ////                                   GREEN          BLUE           PURPLE         RED            WHITE           
                static const float3 colors[5] = { float3(0,1,0), float3(0,0,1), float3(1,0,1), float3(1,0,0), float3(1,1,1)};
                streams.shadowColor = colors[cascadeIndex] * shadow;
            }
            else
            {
                streams.shadowColor = shadow;
            }
        }
    };
}