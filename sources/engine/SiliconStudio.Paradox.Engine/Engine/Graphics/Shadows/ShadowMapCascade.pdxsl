// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
namespace SiliconStudio.Paradox.Effects.Shadows
{
    /// <summary>
    /// Selects the shadow map and computes the shadow factor.
    /// </summary>
    /// <remarks>
    /// TCascadeCount: Number of cascades.
    /// TCascadeDebug: Flag to enable debug mode (1 color per cascade).
    /// </remarks>
    internal class ShadowMapCascade<int TCascadeCount, bool TCascadeDebug> : ShadowMapGroup, ShadowMapFilterBase, PositionStream4
    {
        cbuffer PerPass // TODO: Use a proper cbuffer for this?
        {
            float4x4 WorldToShadowCascadeUV[TCascadeCount];
        };

        float ComputeShadowFromCascade(float3 shadowPositionWS, int cascadeIndex)
        {
            var shadowPosition = mul(float4(shadowPositionWS, 1), WorldToShadowCascadeUV[cascadeIndex]);
            return FilterShadow(shadowPosition.xy, shadowPosition.z);
        }

        override void ComputeShadow(int lightIndex)
        {
            base.ComputeShadow(lightIndex);

            // Only support a single light per group
            float2 shadowMapPos = 0.0;
            float shadowLERP = 0.0f;

            int cascadeIndex = 0;
            [unroll] 
            for(int i = 0; i < TCascadeCount - 1; i++) 
            {
                [flatten]
                if (streams.DepthVS > WorldToShadowCascadeUV[0][i][3])
                {
                    cascadeIndex = i + 1;
                }
            }

            var shadow = ComputeShadowFromCascade(streams.Position.xyz, cascadeIndex);

            streams.shadowColor = shadow;

            //// Calculate shadows with lerp between cascades
            //float shadowMapDistance = shadowMapDepth;
            //float shadow = FilterShadow(shadowMapPos, shadowMapDistance);
            //int nextCascade = foundCascadeIndex + 1;
            //// Only lerp when 
            //if (shadowLERP > 0.0 && shadowLERP < 1.0f && nextCascade < TCascadeCount)
            //{
            //    var shadowMapPos1 = CalculateShadowMapPosition(nextCascade);
            //    shadowMapDistance = CalculateShadowMapDepth(nextCascade);
            //    shadow = lerp(FilterShadow(shadowMapPos1, shadowMapDistance), shadow, shadowLERP);
            //}

            // Output the shadow color
            if (TCascadeDebug)
            {
                //// Display Cascade with colors in debug mode
                ////                        GREEN          BLUE           PURPLE         RED            WHITE           
                static float3 colors[5] = { float3(0,1,0), float3(0,0,1), float3(1,0,1), float3(1,0,0), float3(1,1,1)};
                streams.shadowColor = shadow * colors[cascadeIndex];
            }
        }
    };
}