// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
using SiliconStudio.Paradox.Effects.Data;
using SiliconStudio.Paradox.Effects;
using SiliconStudio.Paradox.Effects.Materials;

namespace SiliconStudio.Paradox.Effects
{
    /// <summary>
    /// Base shader
    /// </summary>
    partial shader ParadoxEffectBase
    {
        using params LightingKeys;
        using params MaterialKeys;
        using params ParadoxEffectBaseKeys;

        // -----------------------------------------------
        // Base shaders
        // -----------------------------------------------
        mixin ShaderBase;
        mixin ShadingBase;

        // -----------------------------------------------
        // Mix material per Vertex Shader
        // -----------------------------------------------
        if (MaterialKeys.VertexStageSurfaceShaders != null)
        {
            // Must come before TransformationBase as this is responsible to modify the vertex input stream
            mixin MaterialSurfaceVertexStageCompositor;  
            mixin compose materialVertexStage = MaterialKeys.VertexStageSurfaceShaders;
            mixin compose streamInitializerVertexStage = MaterialKeys.VertexStageStreamInitializer;
        }

        // -----------------------------------------------
        // Transform vertex stream
        // -----------------------------------------------
        // Come after material surface per vertex
        mixin TransformationBase;
        mixin NormalStream;
        mixin TransformationWAndVP;
        mixin PositionVertexTransform;

        // -----------------------------------------------
        // Performs normal mapping (in case of no-skinning, otherwise it is overloaded below)
        // -----------------------------------------------
        if (MaterialKeys.HasNormalMap)
        {
            mixin NormalFromNormalMapping;
        }
        else
        {
            mixin NormalFromMesh;
        }

        // -----------------------------------------------
        // Performs animation skinning (position, normal and tangent)
        // -----------------------------------------------
        if (MaterialKeys.HasSkinningPosition)
        {
            if (MaterialKeys.SkinningBones > MaterialKeys.SkinningMaxBones)
            {
                // TODO: We should use next power of two minus constant to limit shader permutations?
                MaterialKeys.SkinningMaxBones = MaterialKeys.SkinningBones;
            }
            mixin macro MaterialKeys.SkinningMaxBones;
            mixin TransformationSkinning;

            if (MaterialKeys.HasSkinningNormal)
            {
                mixin NormalMeshSkinning;
            }

            if (MaterialKeys.HasSkinningTangent)
            {
                mixin TangentMeshSkinning;
            }

            if (MaterialKeys.HasSkinningNormal)
            {
                if (MaterialKeys.HasNormalMap)
                {
                    mixin NormalVSSkinningNormalMapping;
                }
                else
                {
                    mixin NormalVSSkinningFromMesh;
                }
            }
        }

        // --------------------------------------------
        // Mix material tessellation for Domain shader
        //---------------------------------------------
        if(MaterialKeys.TessellationShader != null)
        {
            mixin MaterialKeys.TessellationShader;

            if(MaterialKeys.DomainStageSurfaceShaders != null)
            {
                mixin MaterialSurfaceDomainStageCompositor;  
                mixin compose materialDomainStage = MaterialKeys.DomainStageSurfaceShaders;
                mixin compose streamInitializerDomainStage = MaterialKeys.DomainStageStreamInitializer;
            }
        }

        // TODO: Need a flag to detect if we are in scene editor
        mixin child ModelComponentPickingEffect;

        // -----------------------------------------------
        // Mix material and lighting shading for Pixel Shader
        // -----------------------------------------------
        if (MaterialKeys.PixelStageSurfaceShaders != null)
        {
            mixin MaterialSurfacePixelStageCompositor;
            mixin compose materialPixelStage = MaterialKeys.PixelStageSurfaceShaders;
            mixin compose streamInitializerPixelStage = MaterialKeys.PixelStageStreamInitializer;

            if (MaterialKeys.PixelStageSurfaceFilter != null)
            {
                mixin MaterialKeys.PixelStageSurfaceFilter;
            }
        }

        // -----------------------------------------------
        // Add light groups
        // -----------------------------------------------
        var directLightGroups = LightingKeys.DirectLightGroups;
        if (directLightGroups != null)
        {
            foreach(var directLightGroup in directLightGroups)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose directLightGroups += (directLightGroup);
            }
        }

        // -----------------------------------------------
        // Add environment light groups
        // -----------------------------------------------
        var environmentLights = LightingKeys.EnvironmentLights;
        if (environmentLights != null)
        {
            foreach(var environmentLight in environmentLights)
            {
                // Use parenthesis (...) to avoid lightGroup to be interpreted as a mixin named "lightGroup"
                mixin compose environmentLights += (environmentLight);
            }
        }

        // -----------------------------------------------
        // Mix ShadowMap caster 
        // -----------------------------------------------
        if (LightingKeys.CastShadows)
            mixin child ShadowMapCaster;
    };
}